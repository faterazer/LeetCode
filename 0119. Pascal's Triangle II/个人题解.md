# 个人题解

此题可以和 LeetCode 118 题 *杨辉三角* 对比学习。

本题与 118 题的不同在于：118 题要求生成杨辉三角的前 $k$ 行，而本题只要求生成杨辉三角的第 $k$ 行元素。因此，使用 118 题类似的解法即可，区别在于不需要开辟空间对前面的元素进行存储。

这里具体的解释一下实现思路。以实例来阐述，例如当 $k=5$ 时，杨辉三角为：

```()
[1]
[1 1]
[1 2 1]
[1 3 3 1]
[1 4 6 4 1]
[1 5 10 10 5 1]
```

按照杨辉三角的生成规律，我们需要从第一行 `[1]` 开始推，推出第二行 `[1, 1]`，再由 `[1, 1]` 推出第三行 `[1, 2, 1]`。依次类推，直至得到第 `k` 行元素。这里，我们可以发现，按照杨辉三角的生成规律，每次推演都需要之前一行的元素。

为了不开辟额外的存储空间来存贮之前的元素，可以利用一个小技巧：**推算下一行前，在末尾填 0，然后原地计算。**比如对于初始的第 0 行元素 `[1]`，当我们想计算第 1 行元素时，先在其末尾填 0：

```()
[1 0]
```

接着从后往前（从最后一位到第二位数字），每一位的值更新为**其自身与前一位数的和**：

```()
[1 0+1] = [1 1]
```

继续用同样的方法去计算后续的行，如下：

```()
第 2 行:
[1 1 0]
[1 1+1 0+1] = [1 2 1]
第 3 行:
[1 2 1 0]
[1 2+1 1+2 0+1] = [1 3 3 1]
第 4 行:
[1 3 3 1 0]
[1 3+1 3+3 1+3 0+1] = [1 4 6 4 1]
...
```

在实际的实现中，为了方便和运行效率，我们没必要每次都在末尾填 0，而是可以直接开辟一个第 $k$ 行长度的数组：

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1, 0);
        row[0] = 1;
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i; j >= 1; j--)
                row[j] += row[j - 1];
        }
        return row;
    }
};
```
